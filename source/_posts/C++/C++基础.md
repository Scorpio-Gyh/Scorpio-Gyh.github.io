---
title: 1. C++ 基础
date: 2024-05-27 9:30:41
tags: C++
---
# VS相关

## 解决方案

# 工作流程

```cpp
#include <iostream>

int main(){
	std::cout<<"Hello World"<<endl;
	std::cin.get();
}
```

**预处理指令**：预处理器接收源代码，并处理源代码中的预处理指令。预处理指令是以 `#`开头的指令，例如 `#include`、`#define`等。预处理器会处理这些指令，例如包含头文件、处理宏定义等，然后生成预处理后的源代码。

**编译**：编译器接收预处理后的源代码，然后将源代码翻译成汇编代码。编译器在这个过程中会进行语法检查、类型检查、优化等操作。

**汇编**：将文本文件转换为机器码，.cpp文件会被编译，但.h文件不会，.h文件会在预处理阶段被“copy”到.cpp文件中，编译的结果是一个object文件，在windows系统中，是.obj文件

**链接**：链接器接收多个目标文件，然后将这些目标文件链接成一个可执行文件。链接器在这个过程中会解析目标文件中的符号（例如函数和变量的名称），并将这些符号链接到它们在可执行文件中的地址。此过程会将所有obj缝合，构建依赖关系，并形成exe文件。

# 数据类型

**整数类型** ：

* `short`: 通常占用2字节，取值范围通常为-32768到32767。
* `int`: 通常占用4字节，取值范围通常为-2147483648到2147483647。
* `long`: 在32位系统上通常占用4字节，在64位系统上通常占用8字节。
* `long long`: 通常占用8字节，取值范围通常为-9223372036854775808到9223372036854775807。

**字符类型** ：

* `char`: 占用1字节，取值范围通常为-128到127或0到255。
* `wchar_t`: 用于表示宽字符，通常占用2或4字节。

**浮点数类型** ：

* `float`: 占用4字节。
* `double`: 占用8字节。
* `long double`: 占用的字节数依赖于具体的实现，通常为8字节或12字节或16字节。

**布尔类型** ：

* `bool`: 占用1字节，取值为 `true`或 `false`。

**空类型** ：

* `void`: 无值，通常用于表示函数无返回值或指针无指向类型。

# 函数

函数基本结构

```C++
return_type function_name( parameter list ) {
   //body of the function
}
```

* `return_type`：这是函数返回的数据类型。如果函数不返回值，则返回类型为 `void`。
* `function_name`：这是函数的名称。函数名和参数列表共同构成了函数签名。
* `parameter list`：这是传递给函数的参数列表，参数可以是任何类型，包括基本类型、复合类型、指针、引用等。参数列表可以为空。
* `body of the function`：这是函数的主体，包含了函数的具体实现。

函数可以被定义在其他函数之外（全局函数），也可以被定义在类或结构体中（成员函数）。函数可以被其他函数调用，也可以递归地调用自身。

函数可以被声明为 `inline`，这会建议编译器将函数体直接插入到每个调用点，以减少函数调用的开销。

函数可以被声明为 `constexpr`，这表示函数可以在编译时计算结果，这对于模板元编程和编译时计算非常有用。

函数可以被声明为 `virtual`，这表示函数可以被子类覆盖。如果函数被声明为 `pure virtual`，则该函数没有默认实现，必须由子类提供实现。

# 头文件

头文件是一种源代码文件，通常包含函数声明、宏定义、类型定义（如类、结构体和枚举的定义）等。头文件的主要目的是提供接口，使得源代码文件可以共享和重用代码。

头文件通常具有 `.h`或 `.hpp`扩展名（在C++中）。当你在源代码文件中使用 `#include`预处理指令来包含头文件时，预处理器会将整个头文件的内容复制到该指令的位置。

例如，如果你有一个名为 `my_functions.h`的头文件，其中包含了一些函数的声明，你可以在另一个源代码文件中使用以下指令来包含这个头文件：

**#include** **"my_functions.h"**

这样，你就可以在这个源代码文件中调用 `my_functions.h`中声明的函数了。

注意，为了防止头文件的内容在同一编译单元中被多次包含，通常会在头文件中使用预处理指令 `#ifndef`、`#define`和 `#endif`来设置包含保护。例如：

```cpp
#ifndef MY_FUNCTIONS_H
#define MY_FUNCTIONS_H

// function declarations, type definitions, etc.

#endif
```

这样，即使在同一源代码文件中多次包含这个头文件，头文件的内容也只会被包含一次。

**#pragma once 是使得头文件只被包含一次**

"" 一般用于相对位置，但也可包含<>的作用

<>用于包含编译器定义的文件目录

# 指针

指针本质上就是一个整数，该整数指定了内存地址（存放变量的起始地址），指针的类型仅仅指定了访问时所取的内存长度

```cpp
int x = 10;
int* p = &x;  // p是一个指向x的指针// 解引用p，获取x的值
int y = *p;  // y现在是10// 通过解引用p来修改x的值
*p = 20;  // x现在是20
```

# 引用

引用可以被理解为指针的一种语法糖，和指针没有本质区别，可被理解为指针的简化写法

# 类

类（class）是一种用户定义的数据类型，它封装了数据和操作数据的函数。类提供了面向对象编程的基础，包括封装、继承和多态

```cpp
class MyClass {
public:
    MyClass(int a) : a(a) {}  // 构造函数  
int getA() const { return a; }  // 成员函数  
void setA(int a) { this->a = a; }  // 成员函数private:
    int a;  // 数据成员
};
```

## 类和结构体

最主要区别在于默认的访问权限，class为私有，struct为公有

当需要一个全公开的数据结构，倾向于使用结构体

## 构造、析构

* 构造函数是一种特殊的成员函数，它在创建类的新对象时被调用。构造函数的名称与类的名称相同，没有返回类型
* 析构函数是一种特殊的成员函数，它在一个对象即将被销毁时被调用。析构函数的名称是类的名称前面加上一个波浪符（~）

```cpp

class MyClass {
public:
    MyClass() {
        std::cout << "Object is created" << std::endl;
    }

    ~MyClass() {  // 析构函数
        std::cout << "Object is destroyed" << std::endl;
    }
};
```



## 友元函数和友元类

1. **友元函数** ：友元函数是定义在类外部，但有权访问类的所有私有和保护成员的函数。友元函数不是类的成员函数，也不受类的访问控制规则约束，但需要在类内部进行声明。

```cpp
class MyClass {
private:
    int secret = 0;public:
    friend void revealSecret(MyClass& mc);  // 声明友元函数
};
void revealSecret(MyClass& mc) {  // 定义友元函数
    std::cout << mc.secret << std::endl;
}
```

2. **友元类** ：友元类的所有成员函数都可以访问其友元类的私有和保护成员。声明类B为类A的友元，只需要在类A的定义中包含 `friend class B;`。

```cpp
class A {
private:
    int secret = 0;

public:
    friend class B;  // 声明B为A的友元类
};

class B {
public:
    void revealSecret(A& a) {  // B可以访问A的私有成员
        std::cout << a.secret << std::endl;
    }
};
```

友元提供了一种逃避C++的封装性的机制。

然而，过度使用友元可能会导致代码的维护性和可读性降低，因此应谨慎使用。

## 访问控制、可见性

public：公有成员在类的内部和外部都是可见的

private：私有成员只在类的内部可见。你不能在类的外部访问或修改私有成员。

protect：受保护成员在类的内部和其派生类中可见

# static

1. **静态局部变量** ：在函数内部，`static`关键字可以用来声明静态局部变量。这些变量在程序的生命周期内只被初始化一次，而不是每次调用函数时都被初始化。它们的值在函数调用之间保持不变。

```cpp
void func() {
    static int x = 0;
    x++;
    std::cout << x << std::endl;
}
```

2. **静态类成员** ：在类中，`static`关键字可以用来声明静态成员变量和静态成员函数。静态成员变量在所有类的实例中共享，而静态成员函数没有 `this`指针，只能访问类的静态成员。

```cpp
class MyClass {
public:
    static int x;

    static void func() {
        x++;
    }
};

int MyClass::x = 0;  // 静态成员变量需要在类外部初始化
```

3. **静态全局变量和函数** ：在全局作用域中，`static`关键字可以用来限制变量或函数的链接范围到当前文件。这意味着，静态全局变量或函数在其他文件中是不可见的。

```cpp
static int x = 0;  // 只在当前文件可见

static void func() {  // 只在当前文件可见
    x++;
}
```

这些是 `static`关键字在C++中的主要用法。需要注意的是，`static`关键字的具体含义取决于它的上下文。

# enum枚举类

枚举（enum）是一种用户定义的类型，它由一组命名的整数常量组成。

枚举类（enum class）是C++11引入的一种新的枚举类型，它提供了更强的类型安全和更好的作用域规则。

```cpp
enum class Color {
    Red,
    Green,
    Blue
};
```
